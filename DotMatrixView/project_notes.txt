Project notes
=============
Current goal: Make DigitGroup build itself from a simple format string including 0 for digit, : for colon and a space
for a single column space.
NEXT: SO FAR I HAVEN'T IMPLEMENTED A GlyphFactory IN THE REAL PROJECT, NOR MADE USE OF FormatStringParser. Try to do that to gain
insight into the problems in the system.
 
Work out how you configure a GlyphFactory with glyph dimensions, and then how you can parse Glyphs using those dimensions such
that they can tell a grid how to size itself.
Glyph needs to add getWidth() and getHeight(), and setGrid() and render(). Then you can parse a string into
Glyphs, figure out the size required for the grid, and render it once you know.

What is the hierarchy?
Glyph (interface)
	|
	-----------------------------------
	|			 |		  |			  |
DisplayGlyph	Digit	Seperator	Space
	|			 |
	--------------
		   |
	 DisplayDigit
	 
Is it OK for a DisplayDigit to get Glyph from 2 parents? Digit is a sub-interface of Glyph.
DisplayGlyph is an abstract base class for things implementing Glpyh interface. What I really want to do is mix in the digit interface
to a DisplayGlyph.

The interfaces Seperator and Space are not actually being used, because DisplayColon and DisplaySpace extend DisplayGlyph but don't
implement Seperator or Space.

Scenario #1: Grid size is determined by format string
The GlyphFactory is set up with some glyph metrics, which it uses to set up each Glyph. Creating glyphs only initialises them. Parse
a format string to get a list or array of Glyphs. Then total the width by iterating the Glpyhs, and find the height by finding the
tallest.

Scenario #2: Glyphs determine their own size based on the format string and the size of the grid
Is there any point in doing this? Surely the developer would need to decide the space and style they wanted before they
started.

Also need to think about the case where you have more than one line of Glyphs, or where you want to pin the visible Glyphs to the
top, bottom, left or right.

Perhaps I should get some sort of iterator given the format string, calling next() on it gives up a DisplayGlyph? The format itself
could indicate the relationships between the digits?

Format strings:
9 represents a digit with the range 0-9
1 represents a digit with the range 0-1
5 represents a digit with the range 0-5

24-hour: the right digit's range is 0-2. 
		 When the left digit is 0 or 1, the right digit goes from 0-9. 
		 When the left digit is 2, the right digit's range is 0-3
12-hour: the right digit's range is 0-1.
		 When the left digit is 0, the right digit goes from 0-9. 
		 When the left digit is 1, the right digit's range is 0-2. 

Minutes: 5 9 the right digit goes all the way round, the left digit goes from 0-5

When would these rules matter? If I am displaying time, it has to be directly from or relative to a clock. It isn't worth updating it
from an increment or decrement because I cannot deliver them as events to accurate timing.
When it is used as a scoreboard I could increment and decrement, but is there really any point? Would any client application want to
defer score-keeping to this control? I doubt it. Easier to just let it be set as a string (or int or whatever).
NumberSequenceController is useful if you have controls to set the digits by pressing plus and minus buttons. It still might be better
to move that to application code. It just depends whether I want to make setting buttons a core feature of the display itself. 

Thoughts and requirements for building the dot array in code instead of XML:
		Why do I want to do this?
			Because I want more flexible sizes of dots and of the overall control.
				This is what I would expect of a re-useable view.
			It feels like a step towards being able to have more dots than are needed to allow scrolling (horizontal or vertical)
				Scrolling would be a nice visual effect. It would also be useful for touch events, horizontally or vertically showing
				higher and lower values to the left and right/above and below.
		What parts will I need to build to make it work?
			build the view objects based on parameters
			build the digit definitions based on parameters
				define the digits by the parts they are made of
				build the definition of the parts in code
					this approach allows more parts to be defined later
					how do non-digit-width parts like spacers and colons play into this?
				scaling factors - parts know they should take up all the dots available within constraints
					when the digit width is wider, say 21 instead of current 7, the vertical lines should be
					2 or even 3 dots wide
						grids should be divided into proportions. A horizontal is 1 unit of that high and 5 units wide, a vertical
						is 5 of that unit high and 1 unit wide. Spacers are 1 unit. So the dots of a colon would be 1 unit by 1 unit.
					the proportions themselves can be changed? allowing normal, thin or fat characters.

Decide your next experimental direction. Options:
 	Go further with the display piece
 		Improve the animation
 			Try 3.0-style property animations
 			
 			NOTES ON GETTING RID OF THE STACK (OF 2) DOTS:
 			The dot stacks are necessary because without them they fade down to black, then come back to dim at the
			end of the animation. It might be workable if one of these were done:
			a) I used property animation to change the colour instead
			b) If there was no dim dot
			Setting background to a dim dot drawable doesn't help, as the whole view goes tranparent, including the
			background. And changing the animation to not go all the way to transparent doesn't look right, the animation
			and the final switch to dim dot appears to take longer and the whole isn't a smooth transition.
			
 		Touch events
 			The display will need some way to be set to the starting value. I could use vertical dragging to 
 			increment and decrement a digit. While dragging, the digit could slide down a row of dots at a time,
 			with the next higher/lower appearing a row at a time from the top or bottom. If you get beyond a
 			certain number of rows and let go, it will complete the slide in with a springing velocity. If you
 			let go at less than those rows, the current value would spring back. A drag should be effective as a long 
 			motion well beyond the top or bottom of the digit itself - just like the time and date picker dialog in ICS.
 			
 			Figuring out which bit of a digit should show when sliding could be accomplished by working out an index offset
 			against the digit definitions. For example, if a digit was sliding in from the top, and was 2 rows in, which
 			figuring out which dots to turn on, the digit patter values would need to have 11 (of 13) rows subtracted for
 			their destination dots. The index offset would be the index of the start of row 12 (of 13).
 			 
 		Colour changes
 			The countdown will need to be change the dots from green to orange (nearly out) and red (overrun)
 			Consider colours that will look good on a white background. 
 		Build up the segmented display to the same functionality
 			Can set a number
 			Animates to the set number
 			Build segments using a PathDrawable instead of images
 			Build segment animations using lists instead (flip-pad animation)
 		Build dot-array digit from code not XML
 			Construct the arrangement of views in code
 			Given the width and height, figure out which are the active dots
 			Build a single array of dots for all the digits in the display, then let
 			each digit construct itself by figuring out which dots it should own.
 	Figure out the time piece
 		How will update of the display be scheduled to happen
 			When the activity is visible
 			When in the background? Should there be a background service at all?
 		Calculate the current value offset from the start time and the current time
 			Calculate the correct current value from an offset off the time when it started, and every
 			time the display is scheduled to update figure it out again.
 	Build some UI
 		Connect time display with buttons to set the ending time.
 			Might you show both the ending time and the count-down on the screen together?
 	Learn to get appointment times from the calendar content provider
 	Wrap it in a view
 		Such that it can be added to an XML layout
 			Complete with attributes to set it up
 	Make it a library project
 	Use it to make a clock widget
 
 Idea: you could build something in code that is conceptually similar to a real LCD using FrameLayout
 Top of stack:		Shape drawable rectangle whose colour is black and of variable transparency
 					Image file that is a black square with a transparent circle in the middle
 Bottom of stack:	A shape drawable rectangle of whatever colour you want the display to show when lit.
 
 You don't really need the top item above, because you can make the same adjustments at the bottom layer.
 You could use a different mask image to change the shape of the dots, e.g. use snow-flakes around Christmas
 		
 		

The alpha transition makes the spots disappear right down to the background.
	Change it to not go all the way down to zero - it might look passable.
	Make a 3.0-style property animation that takes the colour down to the dim colour.
	Do the shadow properties work on shape drawables?
	
Learn how to target multiple SDK levels so I can optionally use view or property animation.

Make the digits build in code with arbitrary sizes:
	build the original matrices
	build the co-ordinates of the digit parts, spacers and colon
	arguments for building a matrix:
		dots wide
		dots high
		dot size
		spacer width
	
	Should this actually just construct a matrix big enough for the full display, with the
	digits being indexes to items within it?
	
Try building a ShapeDrawable using a Path. The point of the experiment is to see if you can
change the fill colour of such a drawable dynamically, and if so, if the colour can be the
subject of a property animation.
		
	
An eight - all elements on - looks like this:
	    1, 2, 3, 4, 5,
	 7,               13,
	14,               20,
	21,               27,
	28,               34,
	35,               41,
	   43,44,45,46,47,
	49,               55,
	56,               62,
	63,               69,
	70,               76,
	77,               83,
	   85,86,87,88,89